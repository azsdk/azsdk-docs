# Addressing Control Failures
### Contents

### [Fix Control Script](Readme.md#fix-control-script-1)
- [Overview](Readme.md#overview-1)  
- [How to generate fix script?](Readme.md#how-to-generate-fix-script)  
- [How to run fix script generated by AzSDK?](Readme.md#how-to-run-fix-script-generated-by-azsdk)  
- [Repair-AzSDKSubscriptionSecurity](Readme.md#repair-azsdksubscriptionsecurity)  
- [Repair-AzSDKAzureServicesSecurity](Readme.md#repair-azsdkazureservicessecurity)  

### [Control Attestation](Readme.md#control-attestation-1)
- [Overview](Readme.md#overview)  
- [Starting attestation](Readme.md#starting-attestation)  
- [How AzSDK determines the effective control result](Readme.md#how-azsdk-determines-the-effective-control-result)  
- [Permissions required for attesting controls](Readme.md#permissions-required-for-attesting-controls)  
----------------------------------------------------------------

# Fix Control Script
### Overview
For several security controls, the fix required to remediate a control failure is automatable. The AzSDK supports this scenario through the 'FixControls' feature. 
For the controls where this feature is available, AzSDK has the ability to generate a 'control fix' script that the user can review and run to apply the fixes. For many controls, fix automation is not feasible because the workflow involved in fixing a control may be complex. As a result, this feature may not be available/applicable for all controls. 
The overall sequence when using this feature is as follows:
1. A user runs one of the AzSDK scan scripts with a flag requesting the AzSDK to generate a 'control fix' script.
2. Once the scan completes, the user can review the control fix script. 
3. The user can update a parameters file to provide input values for the fix script. This is required for controls where the fix/remediation requires input params to be supplied by the user (e.g., IP addresses, user alias, etc.)
4. The user runs the script to remediate the relevant controls
5. (Optionally) The user can rerun the scan to confirm that the target controls were indeed remediated.    

[Back to top...](Readme.md#contents)

### How to generate fix script?
The script to automatically implement the recommendation for a control can be generated by passing the *'GenerateFixScript'* switch to the following SVT commands:
```PowerShell
	Get-AzSDKAzureServicesSecurityStatus
	Get-AzSDKSubscriptionSecurityStatus
	Get-AzSDKControlsStatus
```

Upon completion of command execution, a folder 'FixControlScripts' will be created in output folder (only if one or more of the failed controls support automated fixing). 
> Note: This folder contains multiple files which are described in a README.txt file in the same folder.


Run the script 'RunFixScript.ps1' from folder 'FixControlScripts'.  

[Back to top...](Readme.md#contents)

### How to run fix script generated by AzSDK?
The recommendation for a control can be implemented automatically by using following commands:
```PowerShell
	Repair-AzSDKAzureServicesSecurity
	Repair-AzSDKSubscriptionSecurity 
```
These commands use the 'FixControlConfig.JSON' file from the 'FixControlScripts' folder for the set of controls to auto-remediate. They are described further below:  

### Repair-AzSDKSubscriptionSecurity
This command remediates the subscription security related controls using the automated fixing scripts generated by running the corresponding AzSDK scan command with the '-GenerateFixScript' flag.

|Parameter|Name|Description|
|----|----|----|
|ParameterFilePath |The full file path to 'FixControlConfig.json' (by default generated in sub-folder 'FixControlScripts' of the AzSDK scan command output folder).|Mandatory|
|ControlIds|The list of control ids for which fixes should be applied.|Optional|
|Force|Switch to bypass user consent of modifying Azure resources|Optional|  

For example,
```PowerShell
Repair-AzSDKSubscriptionSecurity -ParameterFilePath <ParameterFilePath>
```
### Repair-AzSDKAzureServicesSecurity 
This command remediates security controls for various Azure resources using the automated fixing scripts generated by running the corresponding AzSDK scan command with the '-GenerateFixScript' flag.

|Parameter|Name|Description|
|----|----|----|
|ParameterFilePath |The full file path of  'FixControlConfig.json' (by default generated in sub-folder 'FixControlScripts' of the AzSDK scan command output folder). |Mandatory |
|ResourceGroupNames	|The list of resource groups for which fixes should be applied. |Optional |
|ResourceTypes |The list of resource types for which fixes should be applied. E.g., Microsoft.Sql/servers. |Optional |
|ResourceTypeNames |The list of resource type names for which fixes should be applied. E.g., SQLDatabase. |Optional |
|ResourceNames |The list of resources for which fixes should be applied. |Optional |
|ControlIds |The list of control ids for which fixes should be applied. |Optional |
|Force |Switch to bypass user consent prompts when modifying Azure resources |Optional |

For example,
```PowerShell
Repair-AzSDKAzureServicesSecurity -ParameterFilePath <ParameterFilePath>
```
[Back to top...](Readme.md#contents)

# Control Attestation

### Overview

The attestation feature empowers users to support scenarios where human input is required to augment or override the default control 
evaluation status from the AzSDK. These may be situations such as:

- the AzSDK has generated the list of 'Owners' or 'Contributors' for a resource but someone needs to have a look at the list and ratify that 
these are indeed the correct people, or
- the AzSDK has marked a control as failed. However, given the additional contextual knowledge, the application owner wants to ignore the control failure, or
- the AzSDK has marked a control as failed and the issue is a valid security concern. However, due to other constraints, 
the application owner wants to defer the fix for later and request a risk ack.

In all such situations, there is usually a control result that is based on the technical evaluation (e.g., Verify, Failed, etc.) that has to 
be combined with the user's input in order to determine the overall or effective control result. The user is said to have 'attested' such controls 
and, after the process is performed once, AzSDK remembers it and generates an effective control result for subsequent control scans _until_ there 
is a state change.

The attestation feature is implemented via a new switch called *AttestControls* which can be specified in any of the standard security scan cmdlets
of the AzSDK. When this switch is specified, the AzSDK first performs a scan of the target resource(s) like it is business as usual and, once
the scan is complete, it enters a special interactive 'attest mode' where it walks through each resource and relevant attestable controls
and captures inputs from the user and records them in the subscription (along with details about the person who attested, the time, etc.). 
After this, for all future scans on the resource(s), AzSDK will show the effective control evaluation results. Various options are provided to support
different attestation scenarios (e.g., expiry of attestations, edit/change/delete previous attestations, attest only a subset of controls, etc.). 
These are described below. Also, for 'stateful' controls (e.g., "are these the right IP addresses to permit on the firewall?"), the attestation
state is auto-reset if there is any change in 'state' (e.g., someone added a new IP to the list).

Lastly, due to the governance implications, the ability to attest controls is available to a subset of subscription users. This is described in
the permissions required section below.  
 
[Back to top...](Readme.md#contents)
### Starting attestation
      
The AzSDK subscription and services scan cmdlets now support a new switch called *AttestControls*. When this switch is specified, 
AzSDK enters 'attest' mode immediately after a scan is completed. This ensures that attestation is done on the basis of the most current
control statuses.

All controls that have a technical evaluation status of anything other than 'Passed' (i.e., 'Verify' or 'Failed' or 'Manual' or 'Error') are considered 
valid targets for attestation.

To manage attestation flow effectively, 4 options are provided for the *AttestControls* switch to specify which subset of controls to target for attestation. These are described below:

|Attestation Option|Description|
|------------------|-----------|
|NotAttested|Attest only those controls which have not been attested yet.|
|AlreadyAttested|Attest those controls which have past attestations. To re-attest or clear attestation.|
|All|Attest all controls which can be attested (including those that have past attestations).|
|None|N/A.|

For example, to attest controls corresponding to a subscription security scan, run the command below:
```PowerShell  
$subscriptionId = <Your SubscriptionId>
Get-AzSDKSubscriptionSecurityStatus -SubscriptionId $subscriptionId -AttestControls NotAttested -DoNotOpenOutputFolder  
``` 
As shown in the images, the command enters 'attest' mode after completing a scan and does the following:

1. For each resource that was scanned, if a control is a target for attestation, control details (such as description, severity, etc.) and the current evaluation result are displayed (to help the user)
2. The user gets to choose whether they want to attest the control
3. If the user chooses to attest, attestation details (attest status, justification, etc.) are captured
4. This is repeated for all attestable controls and each resource.

 Sample attestation workflow in progress:
 ![02_SVT_Attest_1](../Images/02_SVT_Attest_1.png) 
 
 Sample summary of attestation after workflow is completed:
 ![02_SVT_Attest_2](../Images/02_SVT_Attest_2.png) 

Attestation details corresponding to each control (e.g., justification, user name, etc.) are also captured in the CSV file as shown below:
 ![02_SVT_Attest_3](../Images/02_SVT_Attest_3.png) 

The attestation process for application resources is similar to that for subscriptions. For example, the command below shows how to 
trigger attestation for a specific resource in an RG:
 ```PowerShell  
$subscriptionId = <Your SubscriptionId>
$resourceGroupName = <ResourceGroup Name>
$resourceName = <ResourceName>
Get-AzSDKAzureServicesSecurityStatus -SubscriptionId $subscriptionId -ResourceGroupNames $resourceGroupName -ResourceName $resourceName -AttestControls NotAttested -DoNotOpenOutputFolder 
 ``` 
If, for any reason, the attestations of previously attested controls need to be revisited, it can be done by simply changing the 'NotAttested' flag in the commands above with 'AlreadyAttested'.  

[Back to top...](Readme.md#contents)
### How AzSDK determines the effective control result

During the attestation workflow, the user gets to provide attestation (sub)status for each control attested. This basically represents the user's attestation preference w.r.t.
a specific control (i.e., whether the user wants to override/augment the AzSDK status and treat the control as passed or whether the user agrees with the AzSDK status but wants to defer
fixing the issue for the time being):

|Attestation Status | Description|
|---|---|
|None | There is no attestation done for a given control. User can select this option duriung the workflow to skip the attestation|
|NotAnIssue | User has verified the control data and attesting it as not a issue with proper justification|
|NotFixed | User has verified the control data and attesting it as not fixed with proper justification stating the future fix plan|


The following table shows the complete 'state machine' that is used by AzSDK to support control attestation. 
The columns are described as under:
- 'Control Scan Result' represents the technical evaluation result 
- 'Attestation Status' represents the user choice from an attestation standpoint
- 'Effective Status' reflects the effective control status (combination of technical status and user input)
- 'Requires Justification' indicates whether the corresponding row requires a justification comment
- 'Comments' outlines an example scenario that would map to the row


|Control Scan Result  |Attestation Status |Effective Status|Requires Justification |Comments |
|---|---|---|---|---|
|Passed |None |Passed |No |No need for attestation. Control has passed outright!|
|Verify |None |Verify |No |User has to ratify based on manual examination of AzSDK evaluation log. E.g., SQL DB firewall IPs list.|
|Verify |NotAnIssue |Passed |Yes |User has ratified in the past. E.g., SQL firewall IPs scenario, where all are IPs are legitimate.|
|Verify |NotFixed |RiskAck |Yes |Valid security issue but a fix cannot be implemented immediately. E.g., A 'deprecated' account was found in the subscription. However, the user wants to check any dependecies before removal.|
|Failed |None |Failed |No |Control has failed but has not been attested. Perhaps a fix is in the works...|	 
|Failed |NotAnIssue |Passed |Yes |Control has failed but the issue is benign in a given context business. E.g., Failover instance for a non BC-DR critical service|
|Failed |NotFixed |RiskAck |Yes |Control has failed. The issue is not benign but the user wishes to defer fixing it for later. E.g., AAD is not enabled for Azure SQL DB.|
|Error |None |Error |No |There was an error during evaluation. Manual verification is needed and is still pending.|
|Error |NotAnIssue |Passed |Yes |There was an error during evaluation. However, control has been manually verified by the user.|
|Error |NotFixed |RiskAck |Yes |There was an error during evaluation. Manually verification by the user indicates a valid security issue.|
|Manual |None |Manual |No |The control is not automated and has to be manually verified. Verification is still pending.| 
|Manual |NotAnIssue |Passed |Yes |The control is not automated and has to be manually verified. User has verified that there's no security concern.|
|Manual |NotFixed |RiskAck |Yes |The control is not automated and has to be manually verified. User has reviewed and found a security issue to be fixed.|

  
<br>
The following table describes the possible effective control evaluation results (taking attestation into consideration).

|Control Scan Result| Description|
|---|---|
|Passed |Fully automated control. Azure resource/subscription configuration meeting the AzSDK control requirement|
|Verfiy |Semi automated control. It would emit the required data in the log files which can be validated by the user/auditor.e.g. SQL DB IP ranges|
|Failed |Fully automated contorl. Azure resource/subscription configuration not meeting the AzSDK control requirement|
|Error |Automated control. Currently failing due to some exception. User needs to validate manually|
|Manual |No automation as of now. User needs to validate manually|
|RiskAck |Risk to be Acknowledged. It would trainsition to this control if the user is trying to attest a failed control|

[Back to top...](Readme.md#contents)
### Permissions required for attesting controls:
The attestation feature internally stores state in a storage account in a resource group called AzSDKRG. (This RG is also used by other features in the AzSDK for stateful scenarios.)
If this RG has already been created, then a user needs 'Owner' permission to it.
If this RG is not present (as is possible when none of the scenarios that internally create this RG have been run yet), then the user needs 'Owner' or 'Contributor' permission to the subscription.

> **Note**: The attestation data stored in the AzSDKRG is opaque from an end user standpoint. Any attempts to access/change it may impact correctness of security evaluation results.  

[Back to top...](Readme.md#contents)

